# Cross-Repository Deployment Trigger
# Master workflow that coordinates deployments across repositories
# This workflow can be triggered manually or by other workflows to initiate
# a fully orchestrated cross-repository deployment

name: "ðŸŒ Cross-Repository Deployment Trigger"

on:
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment for deployment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      backend_version:
        description: 'Backend version to deploy'
        required: true
        type: string
      frontend_versions:
        description: 'Frontend versions (JSON format)'
        required: false
        type: string
        default: '{"android": "latest", "ios": "latest", "web": "latest", "desktop": "latest"}'
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        type: choice
        options:
          - sequential
          - parallel
          - canary
        default: sequential
      dry_run:
        description: 'Perform dry run (validation only)'
        required: false
        type: boolean
        default: false
      notification_channels:
        description: 'Notification channels (comma-separated)'
        required: false
        type: string
        default: 'slack,email'
      rollback_on_failure:
        description: 'Enable automatic rollback on failure'
        required: false
        type: boolean
        default: true

  repository_dispatch:
    types: [trigger-cross-repo-deployment]

  workflow_call:
    inputs:
      target_environment:
        description: 'Target environment for deployment'
        required: true
        type: string
      backend_version:
        description: 'Backend version to deploy'
        required: true
        type: string
      frontend_versions:
        description: 'Frontend versions (JSON format)'
        required: false
        type: string
        default: '{"android": "latest", "ios": "latest", "web": "latest", "desktop": "latest"}'
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        type: string
        default: sequential
      dry_run:
        description: 'Perform dry run (validation only)'
        required: false
        type: boolean
        default: false
    outputs:
      deployment_id:
        description: 'Generated deployment ID'
        value: ${{ jobs.orchestrate.outputs.deployment_id }}
      deployment_status:
        description: 'Final deployment status'
        value: ${{ jobs.orchestrate.outputs.deployment_status }}
      deployment_report:
        description: 'Deployment report URL'
        value: ${{ jobs.orchestrate.outputs.deployment_report }}

env:
  DEPLOYMENT_ID: deploy-${{ inputs.target_environment }}-${{ github.run_number }}-${{ github.run_attempt }}
  ORCHESTRATOR_URL: ${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}
  VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}

concurrency:
  group: cross-repo-deploy-${{ inputs.target_environment }}
  cancel-in-progress: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Initialize Cross-Repository Deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  initialize:
    name: "ðŸš€ Initialize Cross-Repository Deployment"
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.init.outputs.deployment_id }}
      can_proceed: ${{ steps.validation.outputs.can_proceed }}
      backend_version: ${{ steps.versions.outputs.backend_version }}
      frontend_versions: ${{ steps.versions.outputs.frontend_versions }}
      deployment_plan: ${{ steps.plan.outputs.deployment_plan }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Dependencies
      run: |
        pip install requests pyyaml pydantic
        pip install -r deployment-orchestration/requirements.txt || echo "No requirements file found"
    
    - name: Initialize Deployment
      id: init
      run: |
        DEPLOYMENT_ID="deploy-${{ inputs.target_environment }}-$(date +%Y%m%d-%H%M%S)-${{ github.run_number }}"
        echo "Generated deployment ID: $DEPLOYMENT_ID"
        echo "::set-output name=deployment_id::$DEPLOYMENT_ID"
        
        # Create deployment directory for artifacts
        mkdir -p deployment-artifacts
        
        # Initialize deployment metadata
        cat > deployment-artifacts/deployment-metadata.json << EOF
        {
          "deployment_id": "$DEPLOYMENT_ID",
          "environment": "${{ inputs.target_environment }}",
          "strategy": "${{ inputs.deployment_strategy }}",
          "dry_run": ${{ inputs.dry_run }},
          "rollback_enabled": ${{ inputs.rollback_on_failure }},
          "initiated_by": "${{ github.actor }}",
          "initiated_at": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
          "source_workflow": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
          "notification_channels": "${{ inputs.notification_channels }}"
        }
        EOF
    
    - name: Validate Deployment Parameters
      id: validation
      run: |
        python -c "
        import json
        import sys
        import re
        
        # Validate environment
        environment = '${{ inputs.target_environment }}'
        if environment not in ['development', 'staging', 'production']:
            print(f'âŒ Invalid environment: {environment}')
            sys.exit(1)
        
        # Validate backend version
        backend_version = '${{ inputs.backend_version }}'
        if not re.match(r'^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?$', backend_version):
            print(f'âŒ Invalid backend version format: {backend_version}')
            sys.exit(1)
        
        # Validate frontend versions JSON
        try:
            frontend_versions = json.loads('${{ inputs.frontend_versions }}')
            if not isinstance(frontend_versions, dict):
                raise ValueError('Frontend versions must be a JSON object')
            
            valid_platforms = ['android', 'ios', 'web', 'desktop']
            for platform in frontend_versions.keys():
                if platform not in valid_platforms:
                    print(f'âš ï¸ Warning: Unknown platform {platform}')
            
        except json.JSONDecodeError as e:
            print(f'âŒ Invalid frontend versions JSON: {e}')
            sys.exit(1)
        
        # Validate deployment strategy
        strategy = '${{ inputs.deployment_strategy }}'
        if strategy not in ['sequential', 'parallel', 'canary']:
            print(f'âŒ Invalid deployment strategy: {strategy}')
            sys.exit(1)
        
        print('âœ… All validation checks passed')
        print('::set-output name=can_proceed::true')
        "
    
    - name: Process Versions
      id: versions
      run: |
        BACKEND_VERSION="${{ inputs.backend_version }}"
        FRONTEND_VERSIONS='${{ inputs.frontend_versions }}'
        
        echo "Backend version: $BACKEND_VERSION"
        echo "Frontend versions: $FRONTEND_VERSIONS"
        
        # Validate versions against version registry
        if [ -n "$VERSION_REGISTRY_URL" ]; then
          echo "ðŸ” Validating versions against registry..."
          
          # Check backend version exists
          BACKEND_CHECK=$(curl -s -f \
            -H "Authorization: Bearer ${{ secrets.VERSION_REGISTRY_TOKEN }}" \
            "$VERSION_REGISTRY_URL/api/v1/versions/backend/$BACKEND_VERSION" || echo "null")
          
          if [ "$BACKEND_CHECK" = "null" ]; then
            echo "âš ï¸ Warning: Backend version $BACKEND_VERSION not found in registry"
          else
            echo "âœ… Backend version validated"
          fi
        fi
        
        echo "::set-output name=backend_version::$BACKEND_VERSION"
        echo "::set-output name=frontend_versions::$FRONTEND_VERSIONS"
    
    - name: Create Deployment Plan
      id: plan
      run: |
        python -c "
        import json
        from datetime import datetime, timezone
        
        deployment_id = '${{ steps.init.outputs.deployment_id }}'
        environment = '${{ inputs.target_environment }}'
        backend_version = '${{ steps.versions.outputs.backend_version }}'
        frontend_versions = json.loads('${{ steps.versions.outputs.frontend_versions }}')
        strategy = '${{ inputs.deployment_strategy }}'
        
        # Create deployment plan
        plan = {
            'deployment_id': deployment_id,
            'environment': environment,
            'strategy': strategy,
            'created_at': datetime.now(timezone.utc).isoformat(),
            'steps': []
        }
        
        if strategy == 'sequential':
            # Backend first, then frontend platforms
            plan['steps'].append({
                'step_id': 'backend-deploy',
                'service': 'backend',
                'version': backend_version,
                'repository': 'mickgian/PratikoAi-BE',
                'workflow': 'orchestrated-deployment.yml',
                'depends_on': [],
                'timeout_minutes': 30
            })
            
            for platform, version in frontend_versions.items():
                plan['steps'].append({
                    'step_id': f'frontend-{platform}-deploy',
                    'service': f'frontend-{platform}',
                    'version': version,
                    'repository': 'mickgian/PratikoAi-KMP', 
                    'workflow': 'orchestrated-frontend-deployment.yml',
                    'depends_on': ['backend-deploy'],
                    'timeout_minutes': 25,
                    'platform': platform
                })
        
        elif strategy == 'parallel':
            # All services in parallel (riskier)
            plan['steps'].append({
                'step_id': 'backend-deploy',
                'service': 'backend',
                'version': backend_version,
                'repository': 'mickgian/PratikoAi-BE',
                'workflow': 'orchestrated-deployment.yml',
                'depends_on': [],
                'timeout_minutes': 30
            })
            
            for platform, version in frontend_versions.items():
                plan['steps'].append({
                    'step_id': f'frontend-{platform}-deploy',
                    'service': f'frontend-{platform}',
                    'version': version,
                    'repository': 'mickgian/PratikoAi-KMP',
                    'workflow': 'orchestrated-frontend-deployment.yml',
                    'depends_on': [],  # No dependencies for parallel
                    'timeout_minutes': 25,
                    'platform': platform
                })
        
        elif strategy == 'canary':
            # Backend + one frontend platform first, then others
            plan['steps'].append({
                'step_id': 'backend-deploy',
                'service': 'backend',
                'version': backend_version,
                'repository': 'mickgian/PratikoAi-BE',
                'workflow': 'orchestrated-deployment.yml',
                'depends_on': [],
                'timeout_minutes': 30
            })
            
            # Deploy web platform first as canary
            if 'web' in frontend_versions:
                plan['steps'].append({
                    'step_id': 'frontend-web-canary',
                    'service': 'frontend-web',
                    'version': frontend_versions['web'],
                    'repository': 'mickgian/PratikoAi-KMP',
                    'workflow': 'orchestrated-frontend-deployment.yml',
                    'depends_on': ['backend-deploy'],
                    'timeout_minutes': 25,
                    'platform': 'web',
                    'canary': True
                })
                
                # Other platforms depend on canary success
                for platform, version in frontend_versions.items():
                    if platform != 'web':
                        plan['steps'].append({
                            'step_id': f'frontend-{platform}-deploy',
                            'service': f'frontend-{platform}',
                            'version': version,
                            'repository': 'mickgian/PratikoAi-KMP',
                            'workflow': 'orchestrated-frontend-deployment.yml',
                            'depends_on': ['frontend-web-canary'],
                            'timeout_minutes': 25,
                            'platform': platform
                        })
        
        # Save plan
        with open('deployment-artifacts/deployment-plan.json', 'w') as f:
            json.dump(plan, f, indent=2)
        
        print(f'Created deployment plan with {len(plan[\"steps\"])} steps')
        print('::set-output name=deployment_plan::' + json.dumps(plan))
        "
    
    - name: Upload Initialization Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-initialization
        path: deployment-artifacts/
        retention-days: 30
    
    - name: Send Initialization Notification
      if: steps.validation.outputs.can_proceed == 'true'
      run: |
        curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          -H "Content-Type: application/json" \
          -d '{
            "attachments": [{
              "color": "#36a64f",
              "title": "ðŸš€ Cross-Repository Deployment Initialized",
              "fields": [
                {"title": "Deployment ID", "value": "${{ steps.init.outputs.deployment_id }}", "short": true},
                {"title": "Environment", "value": "${{ inputs.target_environment }}", "short": true},
                {"title": "Strategy", "value": "${{ inputs.deployment_strategy }}", "short": true},
                {"title": "Backend Version", "value": "${{ steps.versions.outputs.backend_version }}", "short": true}
              ],
              "footer": "PratikoAI Cross-Repo Deployment"
            }]
          }' || echo "Notification failed"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Orchestrate Deployment Execution
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  orchestrate:
    name: "ðŸŽ¯ Orchestrate Deployment Execution"
    runs-on: ubuntu-latest
    needs: initialize
    if: needs.initialize.outputs.can_proceed == 'true' && inputs.dry_run == false
    outputs:
      deployment_id: ${{ needs.initialize.outputs.deployment_id }}
      deployment_status: ${{ steps.execute.outputs.status }}
      deployment_report: ${{ steps.execute.outputs.report_url }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Orchestration Dependencies
      run: |
        pip install requests pyyaml pydantic asyncio httpx
        pip install PyGithub boto3 jinja2
    
    - name: Download Initialization Artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-initialization
        path: ./deployment-artifacts/
    
    - name: Execute Deployment Orchestration
      id: execute
      run: |
        python -c "
        import json
        import asyncio
        import sys
        import os
        
        # Add deployment orchestration to path
        sys.path.append('deployment-orchestration')
        
        from orchestrator import CrossRepoOrchestrator, Environment, ServiceType
        from notification_system import NotificationManager, NotificationType, Severity, DeploymentContext
        
        async def run_orchestration():
            try:
                # Initialize orchestrator
                github_token = os.getenv('GITHUB_TOKEN')
                webhook_url = os.getenv('ORCHESTRATOR_WEBHOOK_URL')
                
                orchestrator = CrossRepoOrchestrator(github_token, webhook_url)
                
                # Load deployment plan
                with open('deployment-artifacts/deployment-plan.json', 'r') as f:
                    plan_data = json.load(f)
                
                print(f'Executing deployment plan: {plan_data[\"deployment_id\"]}')
                
                # Extract versions for plan creation
                backend_version = None
                frontend_versions = {}
                
                for step in plan_data['steps']:
                    if step['service'] == 'backend':
                        backend_version = step['version']
                    elif step['service'].startswith('frontend-'):
                        platform = step['service'].replace('frontend-', '')
                        frontend_versions[platform] = step['version']
                
                # Create deployment plan
                environment = Environment(plan_data['environment'])
                plan = await orchestrator.create_deployment_plan(
                    environment,
                    backend_version,
                    frontend_versions,
                    os.getenv('GITHUB_ACTOR', 'github-actions')
                )
                
                print(f'Created orchestration plan: {plan.plan_id}')
                
                # Execute the plan
                execution = await orchestrator.execute_deployment_plan(plan)
                
                # Create result summary
                result = {
                    'deployment_id': plan.plan_id,
                    'status': execution.status.value,
                    'started_at': execution.started_at.isoformat() if execution.started_at else None,
                    'completed_at': execution.completed_at.isoformat() if execution.completed_at else None,
                    'completed_steps': execution.completed_steps,
                    'failed_steps': execution.failed_steps,
                    'error_message': execution.error_message
                }
                
                # Save execution result
                with open('deployment-artifacts/execution-result.json', 'w') as f:
                    json.dump(result, f, indent=2)
                
                print(f'Deployment execution completed with status: {execution.status.value}')
                print(f'::set-output name=status::{execution.status.value}')
                print(f'::set-output name=report_url::https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}')
                
                # Return appropriate exit code
                if execution.status.value in ['success']:
                    return 0
                else:
                    return 1
                    
            except Exception as e:
                print(f'âŒ Orchestration failed: {str(e)}')
                import traceback
                traceback.print_exc()
                
                # Save error result
                error_result = {
                    'deployment_id': '${{ needs.initialize.outputs.deployment_id }}',
                    'status': 'failed',
                    'error_message': str(e),
                    'completed_steps': [],
                    'failed_steps': ['orchestration']
                }
                
                with open('deployment-artifacts/execution-result.json', 'w') as f:
                    json.dump(error_result, f, indent=2)
                
                print('::set-output name=status::failed')
                return 1
        
        # Run orchestration
        exit_code = asyncio.run(run_orchestration())
        sys.exit(exit_code)
        "
      env:
        GITHUB_TOKEN: ${{ secrets.CROSS_REPO_TOKEN }}
        ORCHESTRATOR_WEBHOOK_URL: ${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}
        ORCHESTRATOR_TOKEN: ${{ secrets.ORCHESTRATOR_TOKEN }}
        VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}
        VERSION_REGISTRY_TOKEN: ${{ secrets.VERSION_REGISTRY_TOKEN }}
        VERSION_REGISTRY_DB_URL: ${{ secrets.VERSION_REGISTRY_DB_URL }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        GITHUB_ACTOR: ${{ github.actor }}
    
    - name: Upload Execution Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: deployment-execution-results
        path: deployment-artifacts/
        retention-days: 90

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Dry Run Validation (Skip Actual Deployment)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dry-run-validation:
    name: "ðŸ§ª Dry Run Validation"
    runs-on: ubuntu-latest
    needs: initialize
    if: needs.initialize.outputs.can_proceed == 'true' && inputs.dry_run == true
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Dependencies
      run: |
        pip install requests pyyaml pydantic
        pip install -r version-management/requirements.txt
    
    - name: Download Initialization Artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-initialization
        path: ./deployment-artifacts/
    
    - name: Validate Deployment Plan
      run: |
        python -c "
        import json
        import sys
        
        # Load and validate deployment plan
        with open('deployment-artifacts/deployment-plan.json', 'r') as f:
            plan = json.load(f)
        
        print('ðŸ§ª Dry Run Validation Results')
        print('=' * 50)
        print(f'Deployment ID: {plan[\"deployment_id\"]}')
        print(f'Environment: {plan[\"environment\"]}')
        print(f'Strategy: {plan[\"strategy\"]}')
        print(f'Total Steps: {len(plan[\"steps\"])}')
        print()
        
        print('Deployment Steps:')
        for i, step in enumerate(plan['steps'], 1):
            print(f'{i}. {step[\"step_id\"]}')
            print(f'   Service: {step[\"service\"]} v{step[\"version\"]}')
            print(f'   Repository: {step[\"repository\"]}')
            print(f'   Workflow: {step[\"workflow\"]}')
            print(f'   Dependencies: {step[\"depends_on\"]}')
            print(f'   Timeout: {step[\"timeout_minutes\"]} minutes')
            print()
        
        print('âœ… Dry run validation completed successfully')
        "
    
    - name: Run Compatibility Checks
      run: |
        echo "ðŸ” Running compatibility checks..."
        
        # Check backend version compatibility
        python version-management/scripts/compatibility_checker.py \
          --service backend \
          --version "${{ needs.initialize.outputs.backend_version }}" \
          --environment "${{ inputs.target_environment }}" \
          --output compatibility-check-backend.json \
          --registry-url "${{ secrets.VERSION_REGISTRY_URL }}" \
          --db-url "${{ secrets.VERSION_REGISTRY_DB_URL }}" \
          --quiet || echo "Backend compatibility check failed"
        
        # Parse frontend versions and check each platform
        python -c "
        import json
        frontend_versions = json.loads('${{ needs.initialize.outputs.frontend_versions }}')
        
        for platform, version in frontend_versions.items():
            print(f'Would check frontend-{platform} v{version} compatibility')
        "
        
        echo "âœ… Compatibility checks completed"
      env:
        VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}
        VERSION_REGISTRY_TOKEN: ${{ secrets.VERSION_REGISTRY_TOKEN }}
        VERSION_REGISTRY_DB_URL: ${{ secrets.VERSION_REGISTRY_DB_URL }}
    
    - name: Generate Dry Run Report
      run: |
        cat > deployment-artifacts/dry-run-report.md << EOF
        # ðŸ§ª Dry Run Deployment Report
        
        **Deployment ID:** ${{ needs.initialize.outputs.deployment_id }}  
        **Environment:** ${{ inputs.target_environment }}  
        **Strategy:** ${{ inputs.deployment_strategy }}  
        **Initiated By:** ${{ github.actor }}  
        **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        
        ## Validation Results
        
        âœ… **Deployment Plan Validation:** Passed  
        âœ… **Parameter Validation:** Passed  
        âœ… **Version Format Validation:** Passed  
        âœ… **Compatibility Checks:** Completed  
        
        ## Deployment Plan Summary
        
        **Backend Version:** ${{ needs.initialize.outputs.backend_version }}  
        **Frontend Versions:** ${{ needs.initialize.outputs.frontend_versions }}  
        
        ## Next Steps
        
        This dry run has validated the deployment configuration. To proceed with the actual deployment:
        
        1. Re-run this workflow with \`dry_run: false\`
        2. Monitor the deployment progress
        3. Verify service health after deployment
        
        ## Notes
        
        - This was a dry run - no actual deployments were performed
        - All validations passed successfully
        - The deployment plan is ready for execution
        
        ---
        *Generated by PratikoAI Cross-Repository Deployment System*
        EOF
        
        echo "ðŸ“‹ Dry run report generated"
        cat deployment-artifacts/dry-run-report.md
    
    - name: Upload Dry Run Results
      uses: actions/upload-artifact@v4
      with:
        name: dry-run-results
        path: deployment-artifacts/
        retention-days: 30

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Final Reporting and Notifications
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  finalize:
    name: "ðŸ“Š Finalize and Report"
    runs-on: ubuntu-latest
    needs: [initialize, orchestrate, dry-run-validation]
    if: always() && needs.initialize.outputs.can_proceed == 'true'
    
    steps:
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: deployment-*
        path: ./all-artifacts/
        merge-multiple: true
    
    - name: Generate Final Report
      run: |
        # Determine overall status
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          OVERALL_STATUS="dry-run-completed"
          EXECUTION_STATUS="skipped"
        else
          OVERALL_STATUS="${{ needs.orchestrate.outputs.deployment_status || 'failed' }}"
          EXECUTION_STATUS="${{ needs.orchestrate.outputs.deployment_status || 'failed' }}"
        fi
        
        # Create comprehensive report
        cat > final-deployment-report.json << EOF
        {
          "deployment_id": "${{ needs.initialize.outputs.deployment_id }}",
          "environment": "${{ inputs.target_environment }}",
          "strategy": "${{ inputs.deployment_strategy }}",
          "dry_run": ${{ inputs.dry_run }},
          "overall_status": "$OVERALL_STATUS",
          "execution_status": "$EXECUTION_STATUS",
          "initiated_by": "${{ github.actor }}",
          "initiated_at": "${{ github.event.head_commit.timestamp || github.event.created_at }}",
          "workflow_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
          "backend_version": "${{ needs.initialize.outputs.backend_version }}",
          "frontend_versions": ${{ needs.initialize.outputs.frontend_versions }},
          "notification_channels": "${{ inputs.notification_channels }}",
          "rollback_enabled": ${{ inputs.rollback_on_failure }}
        }
        EOF
        
        echo "ðŸ“Š Final deployment report:"
        cat final-deployment-report.json | jq .
    
    - name: Send Final Notification
      run: |
        # Determine notification color and message
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          COLOR="#36a64f"
          STATUS_EMOJI="ðŸ§ª"
          STATUS_TEXT="Dry Run Completed"
        elif [ "${{ needs.orchestrate.outputs.deployment_status }}" = "success" ]; then
          COLOR="#36a64f"
          STATUS_EMOJI="âœ…"
          STATUS_TEXT="Deployment Successful"
        else
          COLOR="#ff0000"
          STATUS_EMOJI="âŒ"
          STATUS_TEXT="Deployment Failed"
        fi
        
        # Send Slack notification
        curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          -H "Content-Type: application/json" \
          -d "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"title\": \"$STATUS_EMOJI Cross-Repository Deployment $STATUS_TEXT\",
              \"fields\": [
                {\"title\": \"Deployment ID\", \"value\": \"${{ needs.initialize.outputs.deployment_id }}\", \"short\": true},
                {\"title\": \"Environment\", \"value\": \"${{ inputs.target_environment }}\", \"short\": true},
                {\"title\": \"Strategy\", \"value\": \"${{ inputs.deployment_strategy }}\", \"short\": true},
                {\"title\": \"Backend Version\", \"value\": \"${{ needs.initialize.outputs.backend_version }}\", \"short\": true}
              ],
              \"actions\": [
                {\"type\": \"button\", \"text\": \"View Workflow\", \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
              ],
              \"footer\": \"PratikoAI Cross-Repo Deployment\"
            }]
          }" || echo "Slack notification failed"
    
    - name: Create GitHub Issue on Failure
      if: needs.orchestrate.outputs.deployment_status == 'failed' && inputs.dry_run == false
      uses: actions/github-script@v7
      with:
        script: |
          const title = `ðŸš¨ Cross-Repository Deployment Failed: ${{ needs.initialize.outputs.deployment_id }}`;
          
          const body = `
          # Cross-Repository Deployment Failure
          
          **Deployment ID:** ${{ needs.initialize.outputs.deployment_id }}
          **Environment:** ${{ inputs.target_environment }}
          **Strategy:** ${{ inputs.deployment_strategy }}
          **Initiated By:** ${{ github.actor }}
          **Workflow Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ## Deployment Configuration
          
          - **Backend Version:** ${{ needs.initialize.outputs.backend_version }}
          - **Frontend Versions:** ${{ needs.initialize.outputs.frontend_versions }}
          - **Rollback Enabled:** ${{ inputs.rollback_on_failure }}
          
          ## Status
          
          **Overall Status:** ${{ needs.orchestrate.outputs.deployment_status }}
          
          ## Next Steps
          
          1. Review the workflow logs for detailed error information
          2. Check individual service deployment status
          3. Verify version compatibility and requirements
          4. Consider manual rollback if services are in inconsistent state
          5. Re-run deployment after addressing issues
          
          ## Resources
          
          - [Deployment Report](${{ needs.orchestrate.outputs.deployment_report }})
          - [Version Registry](https://version-registry.pratiko.ai)
          - [Troubleshooting Guide](https://docs.pratiko.ai/deployment/troubleshooting)
          
          ---
          *This issue was automatically created by the cross-repository deployment system.*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body.trim(),
            labels: ['deployment-failure', 'cross-repo', '${{ inputs.target_environment }}']
          });
    
    - name: Upload Final Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: final-deployment-report
        path: |
          final-deployment-report.json
          all-artifacts/
        retention-days: 90