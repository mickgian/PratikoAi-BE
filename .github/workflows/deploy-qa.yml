name: Deploy to QA

on:
  push:
    branches:
      - develop

concurrency:
  group: deploy-qa
  cancel-in-progress: false

jobs:
  tests:
    name: Run Tests
    uses: ./.github/workflows/tests.yml
    permissions:
      contents: write
      pull-requests: write
    secrets: inherit

  build:
    name: Build Images
    needs: tests
    uses: ./.github/workflows/build-images.yml
    permissions:
      contents: read
      packages: write
    secrets: inherit

  deploy:
    name: Deploy to QA Server
    needs: build
    runs-on: ubuntu-latest
    environment: qa

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clean stale paths on QA
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.HETZNER_QA_HOST }}
          username: deploy
          key: ${{ secrets.HETZNER_QA_SSH_KEY }}
          script: |
            # Remove if a previous deploy created these as directories by mistake.
            # Docker creates bind-mount sources as root, so `deploy` user cannot
            # rm them directly. Use a throwaway container (runs as root) instead.
            docker run --rm -v /opt/pratikoai:/workspace alpine sh -c \
              "rm -rf /workspace/docker /workspace/caddy 2>/dev/null; true"

      - name: Sync compose files to QA
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HETZNER_QA_HOST }}
          username: deploy
          key: ${{ secrets.HETZNER_QA_SSH_KEY }}
          source: "docker-compose.yml,docker-compose.qa.yml,scripts/seed_flagsmith_qa.sh,docker/init-flagsmith-db.sh,caddy/Caddyfile"
          target: /opt/pratikoai
          overwrite: true

      - name: Deploy to Hetzner QA
        uses: appleboy/ssh-action@v1
        env:
          FLAGSMITH_ADMIN_EMAIL: ${{ secrets.FLAGSMITH_ADMIN_EMAIL }}
          FLAGSMITH_ADMIN_PASSWORD: ${{ secrets.FLAGSMITH_ADMIN_PASSWORD }}
        with:
          host: ${{ secrets.HETZNER_QA_HOST }}
          username: deploy
          key: ${{ secrets.HETZNER_QA_SSH_KEY }}
          envs: FLAGSMITH_ADMIN_EMAIL,FLAGSMITH_ADMIN_PASSWORD
          script: |
            set -e
            cd /opt/pratikoai

            # Pre-flight: verify required env vars exist in .env.qa
            echo "Checking .env.qa for required variables..."
            MISSING=""
            for var in POSTGRES_USER POSTGRES_PASSWORD POSTGRES_DB REDIS_PASSWORD; do
              if ! grep -q "^${var}=" .env.qa 2>/dev/null; then
                MISSING="$MISSING $var"
              fi
            done
            if [ -n "$MISSING" ]; then
              echo "ERROR: Missing required variables in .env.qa:$MISSING"
              echo "Add them to /opt/pratikoai/.env.qa on the QA server"
              exit 1
            fi
            echo "All required env vars present"

            # Shorthand for docker compose with QA config and env file
            DC="docker compose --env-file .env.qa -f docker-compose.yml -f docker-compose.qa.yml"

            # Login to GHCR
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Set image tag
            export IMAGE_TAG=${{ needs.build.outputs.image_tag }}

            # Remove old pratikoai images to free disk before pulling.
            # Keeps only the currently-running tag; removes all other SHA tags.
            # Get tags of currently-running containers (docker compose images
            # does NOT support Go templates, so we use docker inspect instead).
            _be_id=$($DC ps -q app 2>/dev/null)
            _fe_id=$($DC ps -q frontend 2>/dev/null)
            RUNNING_BE=${_be_id:+$(docker inspect --format '{{.Config.Image}}' "$_be_id" 2>/dev/null | sed 's/.*://')}
            RUNNING_FE=${_fe_id:+$(docker inspect --format '{{.Config.Image}}' "$_fe_id" 2>/dev/null | sed 's/.*://')}
            docker images --format '{{.Repository}}:{{.Tag}}' \
              | grep 'pratikoai-' \
              | grep -v -E "(latest|develop|${RUNNING_BE:-none}|${RUNNING_FE:-none})" \
              | xargs -r docker rmi 2>/dev/null || true
            docker image prune -f || true
            echo "Disk space before pull:" && df -h /

            # Pull new images
            $DC pull app frontend

            # Start infra services first
            $DC up -d db redis
            echo "Waiting for database to be ready..."
            for i in $(seq 1 30); do
              if $DC exec -T db pg_isready -U "${POSTGRES_USER:-aifinance}" > /dev/null 2>&1; then
                echo "Database ready!"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "Database not ready after 150s"
                $DC logs db --tail=30
                exit 1
              fi
              echo "Waiting for database... (attempt $i/30)"
              sleep 5
            done

            # Ensure flagsmith database exists BEFORE starting Flagsmith
            echo "Ensuring flagsmith database exists..."
            $DC exec -T db psql -U "${POSTGRES_USER:-aifinance}" -tc \
              "SELECT 1 FROM pg_database WHERE datname = 'flagsmith'" \
              | grep -q 1 \
              || $DC exec -T db psql -U "${POSTGRES_USER:-aifinance}" -c "CREATE DATABASE flagsmith"
            echo "Flagsmith database ready"

            # Deploy backend + flagsmith (expand-contract: BE always deploys before FE)
            $DC up -d app flagsmith
            echo "Waiting for backend health..."
            sleep 10

            # Check backend health (retry up to 30 times, 5s apart = 2.5 min)
            for i in $(seq 1 30); do
              if $DC exec -T app curl -sf http://localhost:8000/health > /dev/null 2>&1; then
                echo "Backend healthy!"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "Backend health check failed after 30 attempts"
                $DC logs app --tail=50
                exit 1
              fi
              echo "Waiting for backend... (attempt $i/30)"
              sleep 5
            done

            # Seed Flagsmith (idempotent, non-blocking)
            echo "Seeding Flagsmith..."
            chmod +x /opt/pratikoai/scripts/seed_flagsmith_qa.sh
            cd /opt/pratikoai && bash scripts/seed_flagsmith_qa.sh || echo "WARNING: Flagsmith seeding failed (non-blocking, app falls back to env vars)"

            # Restart app to pick up FLAGSMITH_SERVER_KEY if updated
            $DC restart app
            sleep 10
            for i in $(seq 1 20); do
              if $DC exec -T app curl -sf http://localhost:8000/health > /dev/null 2>&1; then
                echo "Backend healthy after restart!"
                break
              fi
              [ "$i" -eq 20 ] && echo "WARNING: Backend health check failed after restart"
              sleep 5
            done

            # Check Flagsmith health (two-phase: wait, then restart+wait if needed)
            echo "Checking Flagsmith health..."
            FLAGSMITH_HEALTHY=false

            # Phase 1: wait up to 150s
            for i in $(seq 1 30); do
              if $DC exec -T app curl -sf http://flagsmith:8000/health > /dev/null 2>&1; then
                FLAGSMITH_HEALTHY=true
                echo "Flagsmith healthy!"
                break
              fi
              echo "Waiting for Flagsmith... (attempt $i/30)"
              sleep 5
            done

            # Phase 2: if still unhealthy, restart and wait another 120s
            if [ "$FLAGSMITH_HEALTHY" = "false" ]; then
              echo "WARNING: Flagsmith not healthy after 150s, restarting..."
              $DC logs flagsmith --tail=30
              $DC restart flagsmith
              for i in $(seq 1 24); do
                if $DC exec -T app curl -sf http://flagsmith:8000/health > /dev/null 2>&1; then
                  FLAGSMITH_HEALTHY=true
                  echo "Flagsmith healthy after restart!"
                  break
                fi
                echo "Waiting for Flagsmith after restart... (attempt $i/24)"
                sleep 5
              done
            fi

            if [ "$FLAGSMITH_HEALTHY" = "false" ]; then
              echo "WARNING: Flagsmith still unhealthy after restart. App falls back to env vars, Caddy uses service_started."
              $DC logs flagsmith --tail=50
            fi

            # Deploy frontend first, then caddy after health gate
            $DC up -d frontend
            echo "Waiting for frontend to be healthy..."
            for i in $(seq 1 20); do
              if $DC exec -T frontend node -e "require('http').get('http://localhost:3000',r=>{process.exit(r.statusCode<400?0:1)}).on('error',()=>process.exit(1))" 2>/dev/null; then
                echo "Frontend healthy!"
                break
              fi
              if [ "$i" -eq 20 ]; then
                echo "ERROR: Frontend not healthy after 100s"
                $DC logs frontend --tail=50
                exit 1
              fi
              echo "Waiting for frontend... (attempt $i/20)"
              sleep 5
            done

            $DC up -d caddy

            # Clean up dangling images left after deploy
            docker image prune -f || true

      - name: Populate knowledge base (one-time)
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.HETZNER_QA_HOST }}
          username: deploy
          key: ${{ secrets.HETZNER_QA_SSH_KEY }}
          command_timeout: 30m
          script: |
            set -e
            cd /opt/pratikoai
            DC="docker compose --env-file .env.qa -f docker-compose.yml -f docker-compose.qa.yml"

            # Check if knowledge base needs initial population
            ITEM_COUNT=$($DC exec -T db psql -U "${POSTGRES_USER:-aifinance}" -d aifinance -tAc \
              "SELECT COUNT(*) FROM knowledge_items" 2>/dev/null || echo "0")
            ITEM_COUNT=$(echo "$ITEM_COUNT" | tr -d ' ')

            if [ "$ITEM_COUNT" -lt 10 ]; then
              echo "Knowledge base nearly empty ($ITEM_COUNT items). Running initial ingestion..."
              echo "This is a one-time operation â€” daily scheduled tasks keep QA current after this."

              # Run full ingestion: RSS feeds + Gazzetta + Cassazione (last 90 days)
              # Non-blocking: partial success (exit 2) is acceptable for initial population
              $DC exec -T app python scripts/run_full_ingestion.py \
                --source all --days 90 || {
                EXIT_CODE=$?
                if [ "$EXIT_CODE" -eq 2 ]; then
                  echo "Initial ingestion completed with partial success (some sources had errors)"
                else
                  echo "WARNING: Initial ingestion failed (exit $EXIT_CODE). Daily tasks will retry."
                fi
              }

              NEW_COUNT=$($DC exec -T db psql -U "${POSTGRES_USER:-aifinance}" -d aifinance -tAc \
                "SELECT COUNT(*) FROM knowledge_items" 2>/dev/null || echo "?")
              echo "Knowledge base now has $(echo $NEW_COUNT | tr -d ' ') items"
            else
              echo "Knowledge base already populated ($ITEM_COUNT items). Skipping initial ingestion."
            fi

      - name: Smoke tests
        if: success()
        run: |
          echo "Running smoke tests against QA..."
          sleep 15

          # Health check
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://api-qa.pratiko.app/health" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "Health check failed with status: $STATUS"
            exit 1
          fi
          echo "Health check passed"

          # Frontend check
          FE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://app-qa.pratiko.app" || echo "000")
          if [ "$FE_STATUS" != "200" ]; then
            echo "Frontend check failed with status: $FE_STATUS"
            exit 1
          fi
          echo "Frontend check passed"

          echo "All smoke tests passed!"

  test:
    name: Run Tests Against QA
    needs: deploy
    runs-on: ubuntu-latest
    continue-on-error: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: '.python-version'

      - name: Run smoke test script
        run: |
          chmod +x scripts/smoke_test.sh
          ./scripts/smoke_test.sh https://api-qa.pratiko.app https://app-qa.pratiko.app

  notify:
    name: Notify Stakeholders
    needs: [deploy, test]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Send deployment notification
        uses: dawidd6/action-send-mail@v3
        if: ${{ vars.STAKEHOLDER_EMAIL != '' }}
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USER }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: |
            [PratikoAI QA] Deploy #${{ github.run_number }} - ${{ needs.deploy.result == 'success' && 'SUCCESS' || 'FAILED' }}
          to: ${{ vars.STAKEHOLDER_EMAIL }}
          from: PratikoAI CI <ci@pratiko.app>
          body: |
            PratikoAI QA Deployment Report
            ==============================

            Status: ${{ needs.deploy.result == 'success' && 'SUCCESS' || 'FAILED' }}
            Tests:  ${{ needs.test.result == 'success' && 'PASSED' || needs.test.result }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}

            URLs:
            - API:  https://api-qa.pratiko.app
            - App:  https://app-qa.pratiko.app

            Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Post summary
        run: |
          echo "## QA Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tests | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
