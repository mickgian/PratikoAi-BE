# Orchestrated Backend Deployment
# Advanced GitHub Actions workflow for coordinated cross-repository deployments
# with dependency management, health validation, and artifact sharing

name: "ğŸš€ Orchestrated Backend Deployment"

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Backend version to deploy'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      deployment_id:
        description: 'Cross-repository deployment ID'
        required: true
        type: string
      service_type:
        description: 'Service type being deployed'
        required: false
        type: string
        default: 'backend'
      orchestrated:
        description: 'Whether this is part of orchestrated deployment'
        required: false
        type: string
        default: 'false'
      frontend_trigger:
        description: 'Trigger frontend deployment after success'
        required: false
        type: boolean
        default: true
      rollback_version:
        description: 'Version to rollback to if deployment fails'
        required: false
        type: string

  workflow_call:
    inputs:
      version:
        description: 'Backend version to deploy'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: string
      deployment_id:
        description: 'Cross-repository deployment ID'
        required: true
        type: string
      orchestrated:
        description: 'Whether this is part of orchestrated deployment'
        required: false
        type: string
        default: 'false'
      frontend_trigger:
        description: 'Trigger frontend deployment after success'
        required: false
        type: boolean
        default: true
    outputs:
      deployment_status:
        description: 'Deployment status (success/failure)'
        value: ${{ jobs.deploy.outputs.status }}
      health_check_url:
        description: 'Health check URL for the deployed service'
        value: ${{ jobs.deploy.outputs.health_url }}
      deployment_info:
        description: 'Deployment information artifact'
        value: ${{ jobs.deploy.outputs.deployment_info }}

env:
  DEPLOYMENT_ID: ${{ inputs.deployment_id }}
  VERSION: ${{ inputs.version }}
  ENVIRONMENT: ${{ inputs.environment }}
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/${{ github.repository }}/pratiko-backend

concurrency:
  group: deploy-backend-${{ inputs.environment }}
  cancel-in-progress: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Pre-deployment Validation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  pre-deployment:
    name: "ğŸ” Pre-deployment Validation"
    runs-on: ubuntu-latest
    outputs:
      can_proceed: ${{ steps.validation.outputs.can_proceed }}
      compatibility_status: ${{ steps.compatibility.outputs.status }}
      previous_version: ${{ steps.version_check.outputs.previous_version }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Dependencies
      run: |
        pip install -r version-management/requirements.txt
        pip install requests pyyaml
    
    - name: Validate Input Parameters
      id: validation
      run: |
        python -c "
        import sys
        import re
        
        version = '${{ inputs.version }}'
        environment = '${{ inputs.environment }}'
        deployment_id = '${{ inputs.deployment_id }}'
        
        # Validate version format
        if not re.match(r'^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?$', version):
            print(f'Invalid version format: {version}')
            sys.exit(1)
        
        # Validate environment
        if environment not in ['development', 'staging', 'production']:
            print(f'Invalid environment: {environment}')
            sys.exit(1)
        
        # Validate deployment ID
        if not deployment_id or len(deployment_id) < 10:
            print(f'Invalid deployment ID: {deployment_id}')
            sys.exit(1)
        
        print('âœ… Input validation passed')
        print('::set-output name=can_proceed::true')
        "
    
    - name: Check Current Deployment Status
      id: version_check
      run: |
        # Get currently deployed version
        if [ "${{ inputs.environment }}" = "production" ]; then
          HEALTH_URL="https://api.pratiko.ai/health"
        elif [ "${{ inputs.environment }}" = "staging" ]; then
          HEALTH_URL="https://api-staging.pratiko.ai/health"
        else
          HEALTH_URL="http://localhost:8000/health"
        fi
        
        # Try to get current version from health endpoint
        CURRENT_VERSION=$(curl -s "$HEALTH_URL" | jq -r '.version // "unknown"' || echo "unknown")
        echo "Current deployed version: $CURRENT_VERSION"
        echo "::set-output name=previous_version::$CURRENT_VERSION"
        
        # Check if we're trying to deploy the same version
        if [ "$CURRENT_VERSION" = "${{ inputs.version }}" ]; then
          echo "âš ï¸ Warning: Attempting to deploy the same version that's currently deployed"
        fi
    
    - name: Run Compatibility Check
      id: compatibility
      run: |
        # Run comprehensive compatibility check
        python version-management/scripts/compatibility_checker.py \
          --service backend \
          --version "${{ inputs.version }}" \
          --environment "${{ inputs.environment }}" \
          --output compatibility-report.json \
          --registry-url "${{ secrets.VERSION_REGISTRY_URL }}" \
          --db-url "${{ secrets.VERSION_REGISTRY_DB_URL }}"
        
        # Check the result
        if [ $? -eq 0 ]; then
          echo "âœ… Compatibility check passed"
          echo "::set-output name=status::compatible"
        else
          echo "âŒ Compatibility check failed"
          echo "::set-output name=status::incompatible"
          
          # Upload compatibility report as artifact
          if [ -f compatibility-report.json ]; then
            echo "Uploading compatibility report..."
          fi
          
          exit 1
        fi
      env:
        VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}
        VERSION_REGISTRY_TOKEN: ${{ secrets.VERSION_REGISTRY_TOKEN }}
        VERSION_REGISTRY_DB_URL: ${{ secrets.VERSION_REGISTRY_DB_URL }}
    
    - name: Upload Compatibility Report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: compatibility-report-${{ inputs.version }}
        path: compatibility-report.json
        retention-days: 30
    
    - name: Notify Orchestrator - Pre-deployment Complete
      if: inputs.orchestrated == 'true'
      run: |
        curl -X POST "${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}/deployment-status" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
          -d '{
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "backend",
            "stage": "pre-deployment",
            "status": "${{ steps.compatibility.outputs.status }}",
            "version": "${{ inputs.version }}",
            "environment": "${{ inputs.environment }}",
            "previous_version": "${{ steps.version_check.outputs.previous_version }}"
          }' || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Build and Test
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  build:
    name: "ğŸ”¨ Build & Test Backend"
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.can_proceed == 'true'
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      build_info: ${{ steps.build.outputs.build_info }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio
    
    - name: Run Tests
      run: |
        pytest tests/ -v --cov=app --cov-report=xml --cov-report=html
        
        # Generate test report
        echo "Test Results:" > test-report.txt
        echo "=============" >> test-report.txt
        pytest tests/ --tb=short >> test-report.txt 2>&1 || true
    
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ inputs.version }}
        path: |
          htmlcov/
          coverage.xml
          test-report.txt
        retention-days: 30
    
    - name: Build Docker Image
      id: build
      run: |
        IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ inputs.version }}"
        LATEST_TAG="${{ env.IMAGE_NAME }}:latest"
        
        # Build image with build args
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag "$IMAGE_TAG" \
          --tag "$LATEST_TAG" \
          --build-arg VERSION="${{ inputs.version }}" \
          --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          --build-arg VCS_REF="${{ github.sha }}" \
          --build-arg DEPLOYMENT_ID="${{ inputs.deployment_id }}" \
          --push \
          .
        
        echo "::set-output name=image_tag::$IMAGE_TAG"
        
        # Create build info
        BUILD_INFO="{
          \"image_tag\": \"$IMAGE_TAG\",
          \"version\": \"${{ inputs.version }}\",
          \"build_date\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\",
          \"git_commit\": \"${{ github.sha }}\",
          \"git_branch\": \"${{ github.ref_name }}\",
          \"deployment_id\": \"${{ inputs.deployment_id }}\",
          \"environment\": \"${{ inputs.environment }}\"
        }"
        
        echo "$BUILD_INFO" > build-info.json
        echo "::set-output name=build_info::$BUILD_INFO"
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-info-${{ inputs.version }}
        path: build-info.json
        retention-days: 30
    
    - name: Security Scan
      if: inputs.environment == 'production'
      run: |
        # Run security scan on production builds
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --severity HIGH,CRITICAL \
          --format json --output security-scan.json \
          "${{ steps.build.outputs.image_tag }}" || true
    
    - name: Upload Security Scan
      if: inputs.environment == 'production'
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-${{ inputs.version }}
        path: security-scan.json
        retention-days: 30

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Deploy Backend Service
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  deploy:
    name: "ğŸš€ Deploy Backend Service"
    runs-on: ubuntu-latest
    needs: [pre-deployment, build]
    outputs:
      status: ${{ steps.deployment.outputs.status }}
      health_url: ${{ steps.deployment.outputs.health_url }}
      deployment_info: ${{ steps.deployment.outputs.deployment_info }}
    
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-info-${{ inputs.version }}
        path: ./artifacts/
    
    - name: Setup Deployment Tools
      run: |
        # Install deployment tools (AWS CLI, kubectl, etc.)
        pip install awscli boto3
        
        # Configure AWS credentials for the environment
        aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
        aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        aws configure set default.region "${{ secrets.AWS_REGION }}"
    
    - name: Deploy to Environment
      id: deployment
      run: |
        echo "ğŸš€ Starting deployment of backend v${{ inputs.version }} to ${{ inputs.environment }}"
        
        # Set environment-specific variables
        case "${{ inputs.environment }}" in
          "production")
            CLUSTER_NAME="pratiko-prod"
            SERVICE_NAME="pratiko-backend"
            HEALTH_URL="https://api.pratiko.ai/health"
            MIN_REPLICAS=3
            MAX_REPLICAS=10
            ;;
          "staging")
            CLUSTER_NAME="pratiko-staging"
            SERVICE_NAME="pratiko-backend-staging"
            HEALTH_URL="https://api-staging.pratiko.ai/health"
            MIN_REPLICAS=2
            MAX_REPLICAS=4
            ;;
          "development")
            CLUSTER_NAME="pratiko-dev"
            SERVICE_NAME="pratiko-backend-dev"
            HEALTH_URL="http://localhost:8000/health"
            MIN_REPLICAS=1
            MAX_REPLICAS=2
            ;;
        esac
        
        echo "::set-output name=health_url::$HEALTH_URL"
        
        # Create deployment configuration
        cat > deployment-config.json << EOF
        {
          "service_name": "$SERVICE_NAME",
          "image": "${{ needs.build.outputs.image_tag }}",
          "version": "${{ inputs.version }}",
          "environment": "${{ inputs.environment }}",
          "deployment_id": "${{ inputs.deployment_id }}",
          "replicas": {
            "min": $MIN_REPLICAS,
            "max": $MAX_REPLICAS
          },
          "health_check": {
            "url": "$HEALTH_URL",
            "timeout": 30,
            "retries": 3
          },
          "rollback": {
            "enabled": true,
            "previous_version": "${{ needs.pre-deployment.outputs.previous_version }}"
          }
        }
        EOF
        
        # Execute deployment using your deployment script
        python scripts/deploy.py \
          --config deployment-config.json \
          --strategy ${{ inputs.environment == 'production' && 'blue-green' || 'rolling' }} \
          --timeout 600 \
          --health-check-retries 5
        
        if [ $? -eq 0 ]; then
          echo "âœ… Deployment successful"
          echo "::set-output name=status::success"
        else
          echo "âŒ Deployment failed"
          echo "::set-output name=status::failed"
          exit 1
        fi
        
        # Create deployment info
        DEPLOYMENT_INFO="{
          \"deployment_id\": \"${{ inputs.deployment_id }}\",
          \"service\": \"backend\",
          \"version\": \"${{ inputs.version }}\",
          \"environment\": \"${{ inputs.environment }}\",
          \"image\": \"${{ needs.build.outputs.image_tag }}\",
          \"health_url\": \"$HEALTH_URL\",
          \"deployed_at\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\",
          \"deployed_by\": \"${{ github.actor }}\",
          \"git_commit\": \"${{ github.sha }}\",
          \"previous_version\": \"${{ needs.pre-deployment.outputs.previous_version }}\"
        }"
        
        echo "$DEPLOYMENT_INFO" > deployment-info.json
        echo "::set-output name=deployment_info::$DEPLOYMENT_INFO"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
    
    - name: Wait for Service Readiness
      if: steps.deployment.outputs.status == 'success'
      run: |
        HEALTH_URL="${{ steps.deployment.outputs.health_url }}"
        echo "ğŸ” Waiting for service to be ready at $HEALTH_URL"
        
        # Wait up to 5 minutes for service to be ready
        for i in {1..30}; do
          echo "Health check attempt $i/30..."
          
          if curl -f -s "$HEALTH_URL" | jq -e '.status == "healthy"' > /dev/null 2>&1; then
            echo "âœ… Service is healthy!"
            break
          fi
          
          if [ $i -eq 30 ]; then
            echo "âŒ Service failed to become healthy within timeout"
            exit 1
          fi
          
          sleep 10
        done
    
    - name: Run Post-deployment Tests
      if: steps.deployment.outputs.status == 'success'
      run: |
        # Run integration tests against deployed service
        HEALTH_URL="${{ steps.deployment.outputs.health_url }}"
        
        echo "ğŸ§ª Running post-deployment tests..."
        
        # Basic API tests
        python -c "
        import requests
        import sys
        
        health_url = '$HEALTH_URL'
        
        try:
            # Health check
            response = requests.get(health_url, timeout=30)
            assert response.status_code == 200
            health_data = response.json()
            assert health_data.get('status') == 'healthy'
            print('âœ… Health check passed')
            
            # Version check
            deployed_version = health_data.get('version')
            expected_version = '${{ inputs.version }}'
            if deployed_version != expected_version:
                print(f'âš ï¸ Warning: Expected version {expected_version}, got {deployed_version}')
            else:
                print('âœ… Version check passed')
            
            print('âœ… All post-deployment tests passed')
            
        except Exception as e:
            print(f'âŒ Post-deployment tests failed: {e}')
            sys.exit(1)
        "
    
    - name: Upload Deployment Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: deployment-info-${{ inputs.version }}
        path: |
          deployment-config.json
          deployment-info.json
        retention-days: 30
    
    - name: Update Version Registry
      if: steps.deployment.outputs.status == 'success'
      run: |
        # Update the version registry with deployment information
        curl -X POST "${{ secrets.VERSION_REGISTRY_URL }}/api/v1/deployments" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.VERSION_REGISTRY_TOKEN }}" \
          -d '{
            "service_type": "backend",
            "version": "${{ inputs.version }}",
            "environment": "${{ inputs.environment }}",
            "deployed_by": "${{ github.actor }}",
            "deployment_id": "${{ inputs.deployment_id }}",
            "deployment_strategy": "github-actions",
            "metadata": {
              "image": "${{ needs.build.outputs.image_tag }}",
              "git_commit": "${{ github.sha }}",
              "workflow_run": "${{ github.run_id }}"
            }
          }' || echo "Warning: Failed to update version registry"
      env:
        VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}
        VERSION_REGISTRY_TOKEN: ${{ secrets.VERSION_REGISTRY_TOKEN }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Trigger Frontend Deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  trigger-frontend:
    name: "ğŸ“± Trigger Frontend Deployment"
    runs-on: ubuntu-latest
    needs: [deploy]
    if: needs.deploy.outputs.status == 'success' && inputs.frontend_trigger == true && inputs.orchestrated == 'true'
    
    steps:
    - name: Get Frontend Version Requirements
      id: frontend_versions
      run: |
        # Query version registry for compatible frontend versions
        COMPATIBLE_VERSIONS=$(curl -s \
          -H "Authorization: Bearer ${{ secrets.VERSION_REGISTRY_TOKEN }}" \
          "${{ secrets.VERSION_REGISTRY_URL }}/api/v1/compatibility/backend/${{ inputs.version }}" | \
          jq -r '.compatibility_matrix | to_entries[] | select(.value == "fully_compatible" or .value == "backward_compatible") | .key' | \
          grep "frontend-" || echo "")
        
        if [ -z "$COMPATIBLE_VERSIONS" ]; then
          echo "No compatible frontend versions found, using latest"
          FRONTEND_VERSIONS='{"android": "latest", "ios": "latest", "web": "latest"}'
        else
          # Parse compatible versions and create JSON
          FRONTEND_VERSIONS=$(echo "$COMPATIBLE_VERSIONS" | python3 -c "
          import sys
          import json
          versions = {}
          for line in sys.stdin:
              if ':' in line:
                  service, version = line.strip().split(':', 1)
                  platform = service.replace('frontend-', '')
                  if platform not in versions:
                      versions[platform] = version
          print(json.dumps(versions))
          ")
        fi
        
        echo "Frontend versions to deploy: $FRONTEND_VERSIONS"
        echo "::set-output name=versions::$FRONTEND_VERSIONS"
      env:
        VERSION_REGISTRY_URL: ${{ secrets.VERSION_REGISTRY_URL }}
        VERSION_REGISTRY_TOKEN: ${{ secrets.VERSION_REGISTRY_TOKEN }}
    
    - name: Trigger Frontend Repository Workflow
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.CROSS_REPO_TOKEN }}
        script: |
          const frontendRepo = 'mickgian/PratikoAi-KMP';
          const workflowFile = 'orchestrated-frontend-deployment.yml';
          
          const response = await github.rest.actions.createWorkflowDispatch({
            owner: 'mickgian',
            repo: 'PratikoAi-KMP',
            workflow_id: workflowFile,
            ref: 'main',
            inputs: {
              deployment_id: '${{ inputs.deployment_id }}',
              environment: '${{ inputs.environment }}',
              backend_version: '${{ inputs.version }}',
              frontend_versions: '${{ steps.frontend_versions.outputs.versions }}',
              backend_health_url: '${{ needs.deploy.outputs.health_url }}',
              orchestrated: 'true'
            }
          });
          
          console.log('Triggered frontend deployment workflow');
          console.log('Response:', response.status);
    
    - name: Notify Orchestrator - Frontend Triggered
      run: |
        curl -X POST "${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}/deployment-status" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
          -d '{
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "backend",
            "stage": "frontend-trigger",
            "status": "triggered",
            "version": "${{ inputs.version }}",
            "environment": "${{ inputs.environment }}",
            "frontend_versions": ${{ steps.frontend_versions.outputs.versions }}
          }' || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Rollback on Failure
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  rollback:
    name: "ğŸ”„ Rollback on Failure"
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy]
    if: failure() && inputs.rollback_version != '' && needs.pre-deployment.outputs.previous_version != 'unknown'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Perform Rollback
      run: |
        ROLLBACK_VERSION="${{ inputs.rollback_version }}"
        if [ -z "$ROLLBACK_VERSION" ]; then
          ROLLBACK_VERSION="${{ needs.pre-deployment.outputs.previous_version }}"
        fi
        
        echo "ğŸ”„ Rolling back to version $ROLLBACK_VERSION"
        
        # Use the same deployment script with rollback flag
        python scripts/deploy.py \
          --rollback \
          --version "$ROLLBACK_VERSION" \
          --environment "${{ inputs.environment }}" \
          --deployment-id "${{ inputs.deployment_id }}-rollback"
    
    - name: Verify Rollback
      run: |
        HEALTH_URL="${{ needs.deploy.outputs.health_url }}"
        
        # Wait for rollback to complete
        sleep 30
        
        # Check service health
        for i in {1..10}; do
          if curl -f -s "$HEALTH_URL" | jq -e '.status == "healthy"' > /dev/null 2>&1; then
            echo "âœ… Rollback successful - service is healthy"
            break
          fi
          
          if [ $i -eq 10 ]; then
            echo "âŒ Rollback verification failed"
            exit 1
          fi
          
          sleep 10
        done
    
    - name: Notify Orchestrator - Rollback Complete
      if: inputs.orchestrated == 'true'
      run: |
        curl -X POST "${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}/deployment-status" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
          -d '{
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "backend",
            "stage": "rollback",
            "status": "completed",
            "version": "${{ inputs.rollback_version || needs.pre-deployment.outputs.previous_version }}",
            "environment": "${{ inputs.environment }}"
          }' || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Notification and Cleanup
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  notify:
    name: "ğŸ“¢ Send Notifications"
    runs-on: ubuntu-latest
    needs: [pre-deployment, build, deploy, trigger-frontend]
    if: always() && inputs.orchestrated == 'true'
    
    steps:
    - name: Determine Overall Status
      id: status
      run: |
        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "::set-output name=overall::success"
          echo "::set-output name=message::Backend deployment completed successfully"
        elif [ "${{ needs.deploy.result }}" = "failure" ]; then
          echo "::set-output name=overall::failure"
          echo "::set-output name=message::Backend deployment failed"
        else
          echo "::set-output name=overall::cancelled"
          echo "::set-output name=message::Backend deployment was cancelled"
        fi
    
    - name: Send Slack Notification
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.status.outputs.overall }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        custom_payload: |
          {
            "attachments": [{
              "color": "${{ steps.status.outputs.overall == 'success' && 'good' || 'danger' }}",
              "title": "ğŸš€ Backend Deployment ${{ steps.status.outputs.overall == 'success' && 'Successful' || 'Failed' }}",
              "fields": [
                {"title": "Environment", "value": "${{ inputs.environment }}", "short": true},
                {"title": "Version", "value": "${{ inputs.version }}", "short": true},
                {"title": "Deployment ID", "value": "${{ inputs.deployment_id }}", "short": true},
                {"title": "Status", "value": "${{ steps.status.outputs.message }}", "short": true}
              ],
              "footer": "PratikoAI Deployment System"
            }]
          }
      if: always()
    
    - name: Create GitHub Issue on Failure
      if: needs.deploy.result == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          const title = `ğŸš¨ Backend Deployment Failed: v${{ inputs.version }} to ${{ inputs.environment }}`;
          const body = `
          # Backend Deployment Failure Report
          
          **Deployment ID:** ${{ inputs.deployment_id }}
          **Version:** ${{ inputs.version }}
          **Environment:** ${{ inputs.environment }}
          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ## Failure Details
          - **Pre-deployment:** ${{ needs.pre-deployment.result }}
          - **Build:** ${{ needs.build.result }}
          - **Deploy:** ${{ needs.deploy.result }}
          
          ## Next Steps
          1. Review the workflow logs
          2. Check service health and compatibility
          3. Consider manual rollback if needed
          4. Update version dependencies if required
          
          ## Artifacts
          Check the workflow run for deployment artifacts and logs.
          
          ---
          *This issue was automatically created by the deployment workflow.*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body,
            labels: ['deployment-failure', 'backend', '${{ inputs.environment }}']
          });
    
    - name: Final Orchestrator Notification  
      run: |
        curl -X POST "${{ secrets.ORCHESTRATOR_WEBHOOK_URL }}/deployment-status" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.ORCHESTRATOR_TOKEN }}" \
          -d '{
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "backend",
            "stage": "complete",
            "status": "${{ steps.status.outputs.overall }}",
            "version": "${{ inputs.version }}",
            "environment": "${{ inputs.environment }}",
            "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "artifacts": {
              "build_info": "${{ needs.build.outputs.build_info }}",
              "deployment_info": "${{ needs.deploy.outputs.deployment_info }}"
            }
          }' || true