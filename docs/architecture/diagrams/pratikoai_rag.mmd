flowchart TD
    %% Entry Point
    Start([S002 · User submits query via POST /api/v1/chat]) --> ValidateRequest[S001 · ChatbotController.chat<br/>Validate request and authenticate]

    ValidateRequest --> ValidCheck{Request valid?}
    ValidCheck -->|Yes| GDPRLog[S004 · GDPRCompliance.record_processing<br/>Log data processing]
    ValidCheck -->|No| Error400[S005 · Return 400 Bad Request]

    GDPRLog --> PrivacyCheck{PRIVACY_ANONYMIZE_REQUESTS<br/>enabled?}
    PrivacyCheck -->|Yes| AnonymizeText[S007 · Anonymizer.anonymize_text<br/>Anonymize PII]
    PrivacyCheck -->|No| InitAgent[S008 · LangGraphAgent.get_response<br/>Initialize workflow]

    AnonymizeText --> PIICheck{PII detected?}
    PIICheck -->|Yes| LogPII[S010 · Logger.info<br/>Log PII anonymization]
    PIICheck -->|No| InitAgent
    LogPII --> InitAgent

    %% Query extraction
    InitAgent --> ConvertMessages[S011 · LangGraphAgent._chat<br/>Convert to Message objects]
    ConvertMessages --> ExtractQuery[S012 · LangGraphAgent._classify_user_query<br/>Extract user message]

    ExtractQuery --> MessageExists{User message<br/>exists?}
    MessageExists -->|Yes| ExtractFacts[S014 · AtomicFactsExtractor.extract<br/>Extract atomic facts]
    MessageExists -->|No| DefaultPrompt[S015 · Continue without classification]

    ExtractFacts --> CanonicalizeFacts[S016 · AtomicFactsExtractor.canonicalize<br/>Normalize dates amounts rates]

    %% NEW: compute attachment hashes early for safe caching
    CanonicalizeFacts --> AttachmentFingerprint[S017 · AttachmentFingerprint.compute<br/>SHA-256 per attachment]
    AttachmentFingerprint --> QuerySig[S018 · QuerySignature.compute<br/>Hash from canonical facts]

    %% Attachment-aware gating + Golden fast-path (pre-LLM)
    QuerySig --> AttachCheck{Attachments present?}
    AttachCheck -->|No| GoldenFastGate[S020 · Golden fast-path eligible?<br/>no doc or quick check safe]
    AttachCheck -->|Yes| QuickPreIngest[S021 · DocPreIngest.quick_extract<br/>type sniff and key fields]
    QuickPreIngest --> DocDependent{Doc-dependent or refers to doc?}
    DocDependent -->|Yes| RequireDocIngest[S023 · PlannerHint.require_doc_ingest_first<br/>ingest then Golden and KB]
    DocDependent -->|No| GoldenFastGate

    GoldenFastGate -->|Yes| GoldenLookup[S024 · GoldenSet.match_by_signature_or_semantic]
    GoldenFastGate -->|No| ClassifyDomain

    GoldenLookup --> GoldenHit{High confidence match?<br/>score at least 0.90}
    GoldenHit -->|Yes| KBContextCheck[S026 · KnowledgeSearch.context_topk<br/>fetch recent KB for changes]
    GoldenHit -->|No| ClassifyDomain

    %% If Golden hits, still consult KB; if KB newer or conflicting -> go to LLM with context
    KBContextCheck --> KBDelta{KB newer than Golden as of<br/>or conflicting tags?}
    KBDelta -->|No| ServeGolden[S028 · Serve Golden answer<br/>with citations]
    KBDelta -->|Yes| PreContextFromGolden[S029 · ContextBuilder.merge<br/>facts and KB docs and doc facts if present]
    ServeGolden --> ReturnComplete[S030 · Return ChatResponse]

    %% Domain classification
    RequireDocIngest --> ClassifyDomain[S031 · DomainActionClassifier.classify<br/>Rule-based classification]
    ClassifyDomain --> CalcScores[S032 · Calculate domain and action scores<br/>Match Italian keywords]
    CalcScores --> ConfidenceCheck{Confidence at least threshold?}
    ConfidenceCheck -->|Yes| TrackMetrics[S034 · ClassificationMetrics.track<br/>Record metrics]
    ConfidenceCheck -->|No| LLMFallback[S035 · DomainActionClassifier._llm_fallback<br/>Use LLM classification]
    LLMFallback --> LLMBetter{LLM better than rule-based?}
    LLMBetter -->|Yes| UseLLM[S037 · Use LLM classification]
    LLMBetter -->|No| UseRuleBased[S038 · Use rule-based classification]
    UseLLM --> TrackMetrics
    UseRuleBased --> TrackMetrics

    %% Always fetch KB context before LLM (RSS never bypassed)
    TrackMetrics --> KBPreFetch[S039 · KnowledgeSearch.retrieve_topk<br/>BM25 and vectors and recency boost]
    PreContextFromGolden --> KBPreFetch
    KBPreFetch --> BuildContext[S040 · ContextBuilder.merge<br/>facts and KB docs and optional doc facts]

    %% Prompt and provider
    BuildContext --> SelectPrompt[S041 · LangGraphAgent._get_system_prompt<br/>Select appropriate prompt]
    DefaultPrompt --> SelectPrompt
    SelectPrompt --> ClassConfidence{Classification exists<br/>and confidence at least 0.6?}
    ClassConfidence -->|Yes| DomainPrompt[S043 · PromptTemplateManager.get_prompt<br/>Get domain-specific prompt]
    ClassConfidence -->|No| DefaultSysPrompt[S044 · Use default SYSTEM_PROMPT]
    DomainPrompt --> CheckSysMsg{System message exists?}
    DefaultSysPrompt --> CheckSysMsg
    CheckSysMsg -->|Yes| ReplaceMsg[S046 · Replace system message]
    CheckSysMsg -->|No| InsertMsg[S047 · Insert system message]
    ReplaceMsg --> SelectProvider[S048 · LangGraphAgent._get_optimal_provider<br/>Select LLM provider]
    InsertMsg --> SelectProvider

    %% LLM Provider Selection
    SelectProvider --> RouteStrategy[S049 · LLMFactory.get_optimal_provider<br/>Apply routing strategy]
    RouteStrategy --> StrategyType{Routing strategy?}
    StrategyType -->|COST_OPTIMIZED| CheapProvider[S051 · Select cheapest provider]
    StrategyType -->|QUALITY_FIRST| BestProvider[S052 · Select best provider]
    StrategyType -->|BALANCED| BalanceProvider[S053 · Balance cost and quality]
    StrategyType -->|FAILOVER| PrimaryProvider[S054 · Use primary provider]
    CheapProvider --> EstimateCost[S055 · CostCalculator.estimate_cost<br/>Calculate query cost]
    BestProvider --> EstimateCost
    BalanceProvider --> EstimateCost
    PrimaryProvider --> EstimateCost
    EstimateCost --> CostCheck{Cost within budget?}
    CostCheck -->|Yes| CreateProvider[S057 · Create provider instance]
    CostCheck -->|No| CheaperProvider[S058 · Select cheaper provider or fail]

    %% Response-level cache check (now uses doc hashes and epochs)
    CreateProvider --> CheckCache[S059 · LangGraphAgent._get_cached_llm_response<br/>Check for cached response]
    CheaperProvider --> CheckCache
    CheckCache --> ResolveEpochs[S060 · EpochStamps.resolve<br/>kb_epoch golden_epoch ccnl_epoch parser_version]
    ResolveEpochs --> GenHash[S061 · CacheService._generate_response_key<br/>sig and doc_hashes and epochs and versions]
    GenHash --> RedisGet[RedisCache.get<br/>Check cache]
    RedisGet --> CacheHit{Cache hit?}
    CacheHit -->|Yes| TrackCacheHit[S062 · UsageTracker.track<br/>Track cache hit]
    CacheHit -->|No| LLMCall[S064 · LLMProvider.chat_completion<br/>Make API call]
    TrackCacheHit --> LogCacheHit[S062 · Logger.info<br/>Log cache hit]
    LogCacheHit --> ReturnCached[S066 · Return cached response]

    %% LLM Execution and Tools
    LLMCall --> LLMSuccess{LLM call successful?}
    LLMSuccess -->|Yes| CacheResponse[S068 · CacheService.cache_response<br/>Store in Redis]
    LLMSuccess -->|No| RetryCheck{Another attempt allowed?}
    RetryCheck -->|Yes| ProdCheck{Prod environment and last retry?}
    RetryCheck -->|No| Error500[S071 · Return 500 error]
    ProdCheck -->|Yes| FailoverProvider[S072 · Get FAILOVER provider]
    ProdCheck -->|No| RetrySame[S073 · Retry same provider]
    FailoverProvider --> LLMCall
    RetrySame --> LLMCall
    CacheResponse --> TrackUsage[S074 · UsageTracker.track<br/>Track API usage]
    TrackUsage --> ToolCheck{Response has tool_calls?}

    ToolCheck -->|Yes| ConvertAIMsg[S076 · Convert to AIMessage<br/>with tool_calls]
    ToolCheck -->|No| SimpleAIMsg[S077 · Convert to simple AIMessage]
    ConvertAIMsg --> ExecuteTools[S078 · LangGraphAgent._tool_call<br/>Execute tools]
    ExecuteTools --> ToolType{Tool type?}

    ToolType -->|Knowledge| KBQueryTool[S080 · KnowledgeSearchTool.search<br/>KB on demand]
    ToolType -->|CCNL| CCNLQuery[S081 · CCNLTool.ccnl_query<br/>Query labor agreements]
    ToolType -->|Document| DocIngest[S082 · DocumentIngestTool.process<br/>Process attachments]
    ToolType -->|FAQ| FAQQuery[S083 · FAQTool.faq_query<br/>Query Golden Set]

    %% Document Ingest Tool Pipeline
    DocIngest --> ValidateAttach[S084 · AttachmentValidator.validate<br/>Check files and limits]
    ValidateAttach --> AttachOK{Valid attachments?}
    AttachOK -->|No| ToolErr[S086 · Return tool error<br/>Invalid file]
    AttachOK -->|Yes| DocSecurity[S087 · DocSanitizer.sanitize<br/>Strip macros and JS]
    DocSecurity --> DocClassify[S088 · DocClassifier.classify<br/>Detect document type]
    DocClassify --> DocType{Document type?}
    DocType -->|Fattura XML| FatturaParser[S090 · FatturaParser.parse_xsd<br/>XSD validation]
    DocType -->|F24| F24Parser[S091 · F24Parser.parse_ocr<br/>Layout aware OCR]
    DocType -->|Contratto| ContractParser[S092 · ContractParser.parse]
    DocType -->|Busta paga| PayslipParser[S093 · PayslipParser.parse]
    DocType -->|Other| GenericOCR[S094 · GenericOCR.parse_with_layout]
    FatturaParser --> ExtractDocFacts[S095 · Extractor.extract<br/>Structured fields]
    F24Parser --> ExtractDocFacts
    ContractParser --> ExtractDocFacts
    PayslipParser --> ExtractDocFacts
    GenericOCR --> ExtractDocFacts
    ExtractDocFacts --> StoreBlob[S096 · BlobStore.put<br/>Encrypted TTL storage]
    StoreBlob --> Provenance[S097 · Provenance.log<br/>Ledger entry]
    Provenance --> ToToolResults[S098 · Convert to ToolMessage<br/>facts and spans]
    ToToolResults --> ToolResults[S099 · Return to tool caller]

    %% Knowledge Tool path
    KBQueryTool --> ToolResults

    %% FAQ Tool path
    FAQQuery --> ToolResults
    GoldenSetDB[(Golden Set / FAQ Store)] -.-> FAQQuery
    GoldenSetDB -.-> GoldenLookup

    %% CCNL Tool path
    CCNLQuery --> PostgresQuery[PostgreSQL<br/>Search CCNL database]
    PostgresQuery --> CCNLCalc[S100 · CCNLCalculator.calculate<br/>Perform calculations]
    CCNLCalc --> ToolResults

    %% Back to agent
    ToolResults --> FinalResponse[S101 · Return to chat node<br/>for final response]
    SimpleAIMsg --> FinalResponse

    %% Response Processing
    FinalResponse --> ProcessMsg[S102 · LangGraphAgent.__process_messages<br/>Convert to dict]
    ReturnCached --> ProcessMsg
    ProcessMsg --> LogComplete[S103 · Logger.info<br/>Log completion]
    LogComplete --> StreamCheck{Streaming requested?}
    StreamCheck -->|Yes| StreamSetup[S105 · ChatbotController.chat_stream<br/>Setup SSE]
    StreamCheck -->|No| ReturnComplete[S030 · Return ChatResponse]
    StreamSetup --> AsyncGen[S106 · Create async generator]
    AsyncGen --> SinglePass[S107 · SinglePassStream<br/>Prevent double iteration]
    SinglePass --> WriteSSE[S108 · write_sse<br/>Format chunks]
    WriteSSE --> StreamResponse[S109 · StreamingResponse<br/>Send chunks]
    StreamResponse --> SendDone[S110 · Send DONE frame]
    SendDone --> CollectMetrics[S111 · Collect usage metrics]
    ReturnComplete --> CollectMetrics
    CollectMetrics --> End([S112 · Return response to user])

    %% Expert Feedback System (async, post-response) + Golden management
    CollectMetrics --> FeedbackUI[S113 · FeedbackUI.show_options<br/>Correct Incomplete Wrong]
    FeedbackUI --> FeedbackProvided{User provides feedback?}
    FeedbackProvided -->|No| FeedbackEnd[S112 · No feedback]
    FeedbackProvided -->|Yes| FeedbackTypeSel[S116 · Feedback type selected]
    FeedbackTypeSel --> FAQFeedback[S117 · POST /api/v1/faq/feedback]
    FeedbackTypeSel --> KnowledgeFeedback[S118 · POST /api/v1/knowledge/feedback]
    FeedbackTypeSel --> ExpertFeedbackCollector[S119 · ExpertFeedbackCollector.collect_feedback]
    FAQFeedback --> ExpertFeedbackCollector
    KnowledgeFeedback --> ExpertFeedbackCollector
    ExpertFeedbackCollector --> ValidateExpert[S120 · Validate expert credentials]
    ValidateExpert --> TrustScoreOK{Trust score at least 0.7?}
    TrustScoreOK -->|No| FeedbackRejected[S122 · Feedback rejected]
    TrustScoreOK -->|Yes| CreateFeedbackRec[S123 · Create ExpertFeedback record]
    CreateFeedbackRec --> UpdateExpertMetrics[S124 · Update expert metrics]
    UpdateExpertMetrics --> CacheFeedback[S125 · Cache feedback 1h TTL]
    CacheFeedback --> DetermineAction[S126 · Determine action]

    DetermineAction --> GoldenCandidate[S127 · GoldenSetUpdater.propose_candidate<br/>from expert feedback]
    GoldenCandidate --> GoldenApproval{Auto threshold met<br/>or manual approval?}
    GoldenApproval -->|Auto or approved| PublishGolden[S129 · GoldenSet.publish_or_update<br/>versioned entry]
    GoldenApproval -->|Rejected| FeedbackEnd
    PublishGolden --> InvalidateFAQCache[S130 · CacheService.invalidate_faq<br/>by id or signature]
    PublishGolden --> VectorReindex[S131 · VectorIndex.upsert_faq<br/>update embeddings]
    PublishGolden --> GoldenSetDB

    %% Background RSS Influence (schedule)
    RSSMonitor[S132 · RSS Monitor] --> FetchFeeds[S133 · Fetch and parse sources]
    FetchFeeds --> ParseDocs[S134 · Extract text and metadata]
    ParseDocs --> KnowledgeStore[(Knowledge Base)]
    KnowledgeStore --> GoldenRules[S135 · GoldenSetUpdater.auto_rule_eval<br/>new or obsolete candidates]
    GoldenRules --> GoldenCandidate

    %% KB wiring (read-only pulls)
    KnowledgeStore -.-> KBPreFetch
    KnowledgeStore -.-> KBContextCheck
    KnowledgeStore -.-> KBQueryTool

    %% Error Paths
    ToolErr --> FinalResponse
    Error400 --> End
    Error500 --> End

    %% Styling
    classDef startEnd fill:#d4f1d4,stroke:#4a7c59,stroke-width:2px,color:#000
    classDef process  fill:#e8f4f8,stroke:#4a90e2,stroke-width:2px,color:#000
    classDef decision fill:#fff4e6,stroke:#f39c12,stroke-width:2px,color:#000
    classDef error    fill:#ffe6e6,stroke:#e74c3c,stroke-width:2px,color:#000
    classDef database fill:#f0e6ff,stroke:#8e44ad,stroke-width:2px,color:#000

    class Start,End startEnd
    class ValidateRequest,GDPRLog,AnonymizeText,LogPII,InitAgent,ConvertMessages,ExtractQuery,ExtractFacts,CanonicalizeFacts,AttachmentFingerprint,QuerySig,AttachCheck,QuickPreIngest,DocDependent,RequireDocIngest,GoldenFastGate,GoldenLookup,GoldenHit,KBContextCheck,KBDelta,ServeGolden,PreContextFromGolden,ClassifyDomain,CalcScores,ConfidenceCheck,TrackMetrics,KBPreFetch,BuildContext,SelectPrompt,DomainPrompt,DefaultSysPrompt,CheckSysMsg,ReplaceMsg,InsertMsg,SelectProvider,RouteStrategy,CheapProvider,BestProvider,BalanceProvider,PrimaryProvider,EstimateCost,CreateProvider,CheaperProvider,CheckCache,ResolveEpochs,GenHash,RedisGet,LLMCall,CacheResponse,TrackUsage,ToolCheck,ConvertAIMsg,ExecuteTools,ToolResults,SimpleAIMsg,FinalResponse,ProcessMsg,LogComplete,StreamSetup,AsyncGen,SinglePass,WriteSSE,StreamResponse,SendDone,ReturnComplete,CollectMetrics,FeedbackUI,FeedbackTypeSel,FAQFeedback,KnowledgeFeedback,ExpertFeedbackCollector,ValidateExpert,CreateFeedbackRec,UpdateExpertMetrics,CacheFeedback,DetermineAction,GoldenCandidate,GoldenApproval,PublishGolden,InvalidateFAQCache,VectorReindex,RSSMonitor,FetchFeeds,ParseDocs,GoldenRules,DocIngest,ValidateAttach,DocSecurity,DocClassify,FatturaParser,F24Parser,ContractParser,PayslipParser,GenericOCR,ExtractDocFacts,StoreBlob,Provenance,ToToolResults,KBQueryTool,CCNLQuery,PostgresQuery,CCNLCalc,ReturnCached,FeedbackEnd process
    class ValidCheck,PIICheck,MessageExists,LLMBetter,ClassConfidence,CheckSysMsg,StrategyType,CostCheck,CacheHit,LLMSuccess,RetryCheck,ProdCheck,ToolType,AttachOK,DocType,StreamCheck,TrustScoreOK,GoldenApproval decision
    class Error400,Error500,ToolErr,FeedbackRejected error
    class RedisGet,PostgresQuery,GoldenSetDB,KnowledgeStore database
